{"version":3,"file":"in-viewport.service.js","sourceRoot":"","sources":["../src/in-viewport.service.ts"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AASzD,IAAa,iBAAiB,GAA9B;IAIE;QACE,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,EAAE,CAAC;IACrC,CAAC;IAES,SAAS,CAAC,OAAoC;QACtD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC;IAES,UAAU,CAAC,MAAe;QAClC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC;IAC9D,CAAC;IAEM,SAAS,CAAC,MAAe,EAAE,WAAqB;QACrD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,iCAAiC;YACjC,MAAM,eAAe,GAAQ;gBAC3B,SAAS,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;aAC/D,CAAC;YAEF,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBAChB,eAAe,CAAC,IAAI,GAAG,WAAW,CAAC;YACrC,CAAC;YAED,uBAAuB;YACvB,MAAM,SAAS,GAAG;gBAChB,MAAM;gBACN,WAAW;gBACX,QAAQ,EAAE,IAAI,oBAAoB,CAChC,CAAC,OAAoC,KAAK,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EACjE,eAAe,CAChB;aACF,CAAC;YAEF,0BAA0B;YAC1B,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAEnC,yBAAyB;YACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAChC,CAAC;IACH,CAAC;IAEM,YAAY,CAAC,MAAe;QACjC,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC1C,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACd,SAAS,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC;YAChC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5D,CAAC;IACH,CAAC;CACF,CAAA;AArDY,iBAAiB;IAD7B,UAAU,EAAE;;GACA,iBAAiB,CAqD7B;SArDY,iBAAiB","sourcesContent":["import { EventEmitter, Injectable } from \"@angular/core\";\n\nexport interface InViewportServiceRegistryObject {\n  target: Element,\n  rootElement: Element,\n  observer: IntersectionObserver\n}\n\n@Injectable()\nexport class InViewportService {\n  protected registry: InViewportServiceRegistryObject[];\n  public trigger$: EventEmitter<IntersectionObserverEntry>;\n\n  constructor() {\n    this.registry = [];\n    this.trigger$ = new EventEmitter();\n  }\n\n  protected onChanges(entries: IntersectionObserverEntry[]): void {\n    this.trigger$.emit(entries[0]);\n  }\n\n  protected findTarget(target: Element) {\n    return this.registry.find((item) => item.target === target);\n  }\n\n  public addTarget(target: Element, rootElement?: Element): void {\n    if (!this.findTarget(target)) {\n      // Create target observer options\n      const observerOptions: any = {\n        threshold: Array(101).fill(void 0).map((item, i) => (i / 100))\n      };\n\n      if (rootElement) {\n        observerOptions.root = rootElement;\n      }\n\n      // Create target object\n      const targetObj = {\n        target,\n        rootElement,\n        observer: new IntersectionObserver(\n          (entries: IntersectionObserverEntry[]) => this.onChanges(entries),\n          observerOptions\n        )\n      };\n\n      // Start to observe target\n      targetObj.observer.observe(target);\n\n      // Add target to registry\n      this.registry.push(targetObj);\n    }\n  }\n\n  public removeTarget(target: Element): void {\n    const targetObj = this.findTarget(target);\n    if (targetObj) {\n      targetObj.observer.disconnect();\n      this.registry.splice(this.registry.indexOf(targetObj), 1);\n    }\n  }\n}\n"]}